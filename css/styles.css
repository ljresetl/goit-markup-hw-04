/* Загальні стилі */
* {
        margin: 0; /* Встановлює нульові відступи для всіх елементів */
        padding: 0; /* Встановлює нульові відступи для всіх елементів */
        box-sizing: border-box; /* Встановлює врахування відступів і рамок у розміри елементів */
}

body {
        font-family: 'Roboto', sans-serif; /* Встановлює шрифт для всього тексту */
        line-height: 1.5; /* Встановлює висоту рядка */
        color: #333; /* Встановлює колір тексту */
        margin: 0; /* Встановлює нульовий відступ для тіла сторінки */
        padding: 0; /* Встановлює нульовий відступ для тіла сторінки */
}

.container {
        max-width: 1158px; /* Максимальна ширина контейнера */
        margin: 0 auto; /* Центрує контейнер по горизонталі */
        padding: 0 15px; /* Відступи по 15px з боків */
}

img {
        display: block; /* перетворення картинки в блоковий елемент */
        max-width: 100%; /* автоматично підлаштовує всі фото під ширину батьківського елемента */
}

/* Хедер */

.page-header {
        border-bottom: 1px solid #e7e9fc; /* Нижня рамка */
}

.header-container {
        padding: 0 15px;
        justify-content: space-between;
        display: flex;
}

.main-logo {
        padding-top: 24px;
        padding-bottom: 24px;
        justify-content: flex-start; /* Вирівнює контент логотипа по лівому краю. */
        font-weight: 700; /* Задає жирність тексту. */
        font-size: 18px; /* Встановлює розмір шрифту у 18px. */
        line-height: 1.17; /* Встановлює висоту міжрядкового інтервалу. */
        letter-spacing: 0.03em; /* Додає невеликий відступ між літерами. */
        text-transform: uppercase; /* Змінює всі літери на великі. */
        color: #4d5ae5; /* Встановлює синій колір тексту. */
        font-family: "Raleway", sans-serif; /* Використовує шрифт "Raleway". */
        font-weight: bold;
        text-transform: uppercase;
        text-decoration: none;
        margin-right: 76px; /* Відступ для логотипа */
}

.main-logo span {
        color: #2e2f42; /* Встановлює темно-сірий колір тексту. */
        
}

.menu {
        font-weight: 500; /* Встановлює середню жирність тексту. */
        font-size: 16px; /* Встановлює розмір шрифту у 16px. */
        line-height: 1.5; /* Встановлює висоту міжрядкового інтервалу. */
        letter-spacing: 0.02em; /* Додає невеликий відступ між літерами. */
        color: #2e2f42; /* Встановлює темно-сірий колір тексту. */
        font-family: "Roboto", sans-serif; /* Використовує шрифт "Roboto". */
        align-items: center;
        display: flex; /* Горизонтальне розташування меню */
}

.menu-list {
        display: flex; /* Горизонтальне вирівнювання пунктів меню */
        gap: 40px; /* Відстань між пунктами меню */
        list-style: none; /* Прибрано маркери */
        margin: 0;
        padding: 0;
}

.menu-link {
        padding-top: 24px;
        padding-bottom: 24px;
        text-decoration: none; /* Прибрано підкреслення */
        font-size: 16px;
        color: #333;
        transition: color 0.3s ease; /* Анімація зміни кольору */
}

.menu-link:hover {
        color: #404bbf; /* Змінює колір тексту на синій при наведенні. */
}

.menu-link:focus {
        color: #404bbf; /* Змінює колір тексту на синій при фокусі. */
}

.contacts {
        font-style: normal; /* Змінює стиль шрифту на звичайний. */
        gap: 40px;
        /*display: flex; Горизонтальне вирівнювання контактів */
}

.contacts-list {
        display: flex; /*Горизонтальне розташування контактів */
        gap: 40px; /* Відстань між контактами */
        list-style: none; /* Прибрано маркери */
        margin: 0;
        padding: 0;
}

.contacts-link {
        display: block;
        padding-top: 24px;
        padding-bottom: 24px;
        font-weight: 400; /* Встановлює нормальну жирність тексту. */
        font-size: 16px; /* Задає розмір тексту. */
        line-height: 1.5; /* Встановлює міжрядковий інтервал. */
        letter-spacing: 0.02em; /* Додає відступ між літерами. */
        color: #434455; /* Встановлює основний колір тексту. */
        font-family: "Roboto", sans-serif; /* Використовує шрифт "Roboto". */
        font-style: normal; /* Змінює стиль шрифту на звичайний. */
        text-decoration: none; /* Прибрано підкреслення */
        font-size: 14px;
        color: #333;
        transition: color 0.3s ease; /* Ефект при наведенні */
}

.contacts-link:hover {
        color: #404bbf; /* Змінює колір тексту на синій при наведенні. */
}

.contacts-link:focus {
        color: #404bbf; /* Змінює колір тексту на синій при наведенні. */
}

/* Головний банер */
.one-section {
        background-color: #2e2f42; /* Задає темно-сірий фон для секції. */
        color: white; /* Білий текст */
        text-align: center; /* Центрує текст */
        /* padding-bottom: 292px;
        padding-left: 472px;
        padding-top: 116px;
        padding-right: 472px; */
        padding-top: 188px;
        padding-bottom: 188px;
}

.one-h {
        font-weight: 700; /* Задає жирність тексту. */
        font-size: 56px; /* Встановлює великий розмір шрифту для заголовка. */
        line-height: 1.07; /* Встановлює міжрядковий інтервал. */
        letter-spacing: 0.02em; /* Додає відступ між літерами. */
        text-align: center; /* Центрує текст. */
        color: #fff; /* Робить текст білим. */
        font-family: "Roboto", sans-serif; /* Використовує шрифт "Roboto". */
        margin-bottom: 0px; /* Відступ знизу */
        max-width: 496px; /* Обмеження ширини заголовка */
        margin: 0 auto; /* Центрування заголовка */
}

.one-button {
        background-color: #4d5ae5; /* Встановлює синій фон кнопки. */
        font-family: "Roboto", sans-serif; /* Використовує шрифт "Roboto". */
        font-weight: 500; /* Встановлює середню жирність тексту. */
        font-size: 16px; /* Задає розмір тексту. */
        line-height: 1.5; /* Встановлює міжрядковий інтервал. */
        letter-spacing: 0.04em; /* Додає відступ між літерами. */
        color: #fff; /* Робить текст білим. */
        cursor: pointer; /* Додає вигляд курсора "рука" при наведенні. */
        display: block; /* Для центрування кнопки */
        margin: 0 auto; /* Центрування через margin */
        min-width: 169px; /* Мінімальна ширина кнопки */
        height: 56px; /* Висота кнопки */
        padding: 10px 20px; /* Відступи всередині кнопки */
        border: none; /* Без рамки */
        border-radius: 4px; /* Заокруглені кути */
        cursor: pointer; /* Курсор у вигляді руки */
        transition: background-color 0.3s ease; /* Анімація зміни кольору при ховері */
        margin-top: 48px;
}

.one-button:hover {
        background-color: #404BBF; /* Змінює фон кнопки на темно-синій при наведенні. */
}

.one-button:focus {
        background-color: #404BBF; /* Змінює фон кнопки на темно-синій при фокусі. */
}

/* Розділ "Advantages" */
.two-section {
        padding: 120px 0; /* Відступи зверху і знизу */
}

.main-logo {
        display: inline-block;
}

.visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        margin: -1px;
        border: 0;
        padding: 0;
        white-space: nowrap;
        clip-path: inset(100%);
        clip: rect(0 0 0 0);
        overflow: hidden;
}

.two-section-ul {
        display: flex;
        grid-template-columns: repeat(4, 1fr); /* Розміщує елементи в 4 колонки */
        gap: 24px; /* Відстань між елементами */
        list-style: none; /* Прибирає маркери списку */
}

.two-section-li {
        width: calc((100% - 72px) / 4);
        /*text-align: center;  Центрує елементи списку */
}

.three-strategy-h {
        font-weight: 500; /* Встановлює середню жирність тексту. */
        font-size: 20px; /* Задає розмір шрифту. */
        line-height: 1.2; /* Встановлює міжрядковий інтервал. */
        letter-spacing: 0.02em; /* Додає відступ між літерами. */
        color: #2e2f42; /* Встановлює темно-сірий колір тексту. */
        font-family: "Roboto", sans-serif; /* Використовує шрифт "Roboto". */
        margin-bottom: 8px; /* Відступ знизу */
}

.three-strategy-p {
        font-weight: 400; /* Встановлює нормальну жирність тексту. */
        font-size: 16px; /* Задає розмір тексту. */
        line-height: 1.5; /* Встановлює міжрядковий інтервал. */
        letter-spacing: 0.02em; /* Додає відступ між літерами. */
        color: #434455; /* Встановлює основний колір тексту. */
        font-family: "Roboto", sans-serif; /* Використовує шрифт "Roboto". */
}


/* Розділ "Our Team" */

.three-section {
        background-color: #F4F4FD; /* Встановлює світло-бузковий фон секції. */
        padding: 120px 0; /* Відступи зверху і знизу */
}

.three-section-h {
        font-family: "Roboto", sans-serif; /* Використовує шрифт "Roboto". */
        font-weight: 700; /* Задає жирність тексту. */
        font-size: 36px; /* Задає розмір тексту. */
        line-height: 1.11; /* Встановлює міжрядковий інтервал. */
        letter-spacing: 0.02em; /* Додає відступ між літерами. */
        text-align: center; /* Центрує текст. */
        color: #2e2f42; /* Встановлює темно-сірий колір тексту. */
        text-transform: capitalize; /* Перетворює першу літеру кожного слова на велику. */
        margin-bottom: 72px;
        
}

.three-section-list {
        display: flex; /* Горизонтальне вирівнювання елементів списку */
        gap: 24px; /* Відстань між елементами списку */
        justify-content: center; /* Центрування списку */
        list-style: none; /* Прибирає маркери списку */
        padding: 0; /* Вирівнювання відступів */
        margin: 0; /* Вирівнювання відступів */
}

.three-section-item {
        background-color: #fff; /* Задає білий фон для першого елемента списку. */

        border-radius: 0px 0px 4px 4px;
        flex-basis: calc((100% - 3 * 24px) / 4); /* Пропорційна ширина кожного елемента */
        text-align: center; /* Центрування тексту */
}


.team-name {
        font-weight: 500; /* Встановлює середню жирність тексту. */
        font-size: 20px; /* Задає розмір шрифту. */
        line-height: 1.2; /* Встановлює міжрядковий інтервал. */
        letter-spacing: 0.02em; /* Додає відступ між літерами. */
        text-align: center; /* Центрує текст. */
        color: #2e2f42; /* Встановлює темно-сірий колір тексту. */
        font-family: "Roboto", sans-serif; /* Використовує шрифт "Roboto". */
        margin-bottom: 8px; /* Відступ знизу */
}

.team-role {
        font-weight: 400; /* Встановлює нормальну жирність тексту. */
        font-size: 16px; /* Задає розмір тексту. */
        line-height: 1.5; /* Встановлює міжрядковий інтервал. */
        letter-spacing: 0.02em; /* Додає відступ між літерами. */
        text-align: center; /* Центрує текст. */
        color: #434455; /* Встановлює основний колір тексту. */
        font-family: "Roboto", sans-serif; /* Використовує шрифт "Roboto". */
}

.div-name-role {
        padding: 32px 0;

}

/* Розділ "Our Portfolio" */
.four_section {
        padding: 120px 0;
}

.ourportfolio {
        max-width: 1158px; /* Максимальна ширина контейнера */
        margin: 0 auto; /* Центрує контейнер по горизонталі */
        padding: 0 15px; /* Відступи по 15px з боків */
}

.four-section-h {
        font-family: "Roboto", sans-serif;
        font-weight: 700;
        font-size: 36px;
        line-height: 1.11111;
        letter-spacing: 0.02em;
        text-align: center;
        color: #2e2f42;
        margin-bottom: 72px; /* Відступ між заголовком і списком */
}

.four_section_list {
        display: flex;
        flex-wrap: wrap;
        column-gap: 24px;
        row-gap: 48px;
        list-style-type: none; /* Прибирає маркери списку */
        padding: 0; /* Видаляє відступи по замовчуванню */
        margin: 0; /* Видаляє відступи по замовчуванню */
}

.four_section_li {
        width: calc((100% - 48px) / 3);
}

.spusok {
        padding: 32px 16px;
        border: 1px solid #e7e9fc;
        border-top: none;
}

.four_section_h_one {
        margin-bottom: 8px;
        font-family: "Roboto", sans-serif;
        font-weight: 500;
        font-size: 20px;
        line-height: 1.2;
        letter-spacing: 0.02em;
        color: #2e2f42;
}

.four_section_p_one {
        font-weight: 400;
        font-size: 16px;
        line-height: 1.5;
        letter-spacing: 0.02em;
        color: #434455;
}
/* Футер */
.footer_test {
        background: #2e2f42; /* Встановлює темно-сірий фон для футера. */
        padding: 100px 0; /*Відступи зверху і знизу */
        color: #777; /* Колір тексту */
}

.footer_test a {
        display: inline-block; /*Блочні властивості для посилання */
        margin-bottom: 16px; /*Відступ між посиланням та параграфом */
}

.footer_test .main_logo {
        font-weight: 700;
        font-size: 18px;
        line-height: 1.16667;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #4d5ae5;
        text-decoration: none; /* Прибирає підкреслення з логотипа */

        


}

.footer_test .main_logo span {
        color: #f4f4fd;
}

.text_p_footer {
        font-weight: 400;
        font-size: 16px;
        line-height: 1.5;
        letter-spacing: 0.02em;
        color: #f4f4fd;
        font-family: "Roboto", sans-serif; /* Використовує шрифт "Roboto". */ 
        max-width: 264px; /* Максимальна ширина тексту */

}

/* Падінг (англ. padding, внутрішнє поле) — це відстань між контентом елемента і його рамкою (border). 
Використовується для декоративних ефектів. Не можна вказувати негативні значення. */

/* Рамка (border) — межа елемента. За замовчуванням її ширина дорівнює нулю. Якщо колір рамки не встановлено,
вона приймає колір основного вмісту,
наприклад тексту. */

/* Маржин (англ. margin, зовнішній відступ) — додає відступ ззовні елемента,
від зовнішньої межі (рамки) до сусідніх елементів,
тим самим розділяючи їх на сторінці. Маржину можна вказувати негативне значення. Фон елемента на зовнішній відступ не поширюється. */

/* Ширина=width+padding-left+padding-right+border-left+border-right 
Висота=height+padding-top+padding-bottom+border-top+border-bottom */

/* Значення border-box У цій блоковій моделі властивості width і height задають кінцеві розміри елемента,
а не його області вмісту. Контент автоматично «стискається» так,
щоб всередині контейнера ще вмістилися padding і border . */

/* *,
*::before,
*::after {
        box-sizing: border-box;
} правило для глобального значення властивості box-sizing зі значенням border-box. */

/* Властивість padding — властивість,
яка контролює внутрішні поля між вмістом і рамкою для всіх сторін елемента: зверху (top),
справа (right),
знизу (bottom) і зліва (left). Саме в такому порядку за годинниковою стрілкою,
починаючи зверху,
задаються значення складових цієї властивості. */

/* Поле зверху 10px, праворуч 15px, знизу 20px, ліворуч 25px
padding: 10px 15px 20px 25px; */

/* Навіть якщо властивості рамки явно не задані,
вона все одно існує. За замовчуванням її ширина дорівнює 0 і вона бере участь у побудові геометрії елемента,
тому падінг між рамкою та вмістом можна задати завжди. */

/* Складова властивість margin контролює зовнішні відступи від рамки до 
сусідніх елементів для всіх сторін елемента. Результат роботи залежить від того,
скільки значень властивості вказано.
/* Відступ зверху 10px, праворуч 15px, знизу 20px, зліва 25px
margin: 10px 15px 20px 25px; */

/* Властивість padding відокремлює вміст від рамки елемента. 
Властивість margin створює проміжки між сусідніми елементами. */

/* Якщо вам важко запам’ятати,
де використовувати падінг,
а де маржин,
під час верстки задавайте всім елементам колір фону,
адже він поширюється тільки на вміст,
падінг і рамку,
але не на маржини. Так буде візуально зрозуміло. Після того,
як верстка виконана,
видаліть із CSS-правил допоміжні властивості кольору фона. */

/* Обнулення маржина body вже є певним «стандартом» сучасної розробки,
то ж нормалізатор modern-normalize містить цей крок. Тому,
якщо на вашій веб-сторінці застосовується нормалізатор,
,
обнуляти маржин body у своєму коді не потрібно. */

/* border: ширина стиль колір; */
/* 
Ширина рамки визначається в пікселях. Стиль — одне значення з набору можливих значень,
найпоширенішими значеннями є solid,
dashed і dotted. Колір задається в будь-якому форматі,
зазвичай HEX */

/* А ось задати рамку тільки з однієї сторони елемента — це саме той випадок,
в якому ці властивості стануть у нагоді. */

/* border-top: ширина стиль колір;
border-right: ширина стиль колір;
border-bottom: ширина стиль колір;
border-left: ширина стиль колір; */

/* Аби заокруглити всі кути рамки,
застосовується властивість border-radius. Значення можуть бути як абсолютні (px),
так і відносні (%). Якщо квадратному елементу задати радіус 50%,
це перетворить його на коло. */

/* Так само є властивості,
що дозволяють заокруглити кожен кут рамки окремо. */
/* верхній лівий кут
border-top-left-radius: значення;

/* верхній правий кут
border-top-right-radius: значення;

/* нижній правий кут
border-bottom-right-radius: значення;

/* нижній лівий кут
border-bottom-left-radius: значення; */

/* Через те,
що зображення завжди переповнює блок,
візуально виходячи за його рамки,
маємо не зовсім те,
що потрібно.
Тут допоможе властивість overflow та її значення hidden,
яке задається «тумбі» та контролює видимість контенту,
що виходить за рамки. Колір і розмір рамки у прикладі задані для візуалізації,
встановлювати будь-які значення,
крім радіуса,
не обов'язково. */

/* Властивість overflow Розміри елемента: Визначаються контентом усередині або Задаються явно. Що відбувається,
коли змінюється вміст усередині елемента? У першому випадку,
коли висоту елемента не встановлено явно,
висота збільшуватиметься,
доки в елементі не поміститься весь контент У другому випадку ширина та висота вказані явно. Отже,
блок не може збільшитися,
і вміст його переповнює,
тобто виходить за його межі. Властивість overflow керує поведінкою вмісту елемента,
якщо його розмір перевищує припустиму висоту чи ширину. overflow: visible | hidden | scroll | auto Також є властивості overflow-x і overflow-y,
що контролюють переповнення тільки у відповідній площині. */

/* Протилежне значення — hidden. У цьому випадку будь-який вміст,
що виходить за межі елемента,
не відображається. */

/* При значенні scroll,
контент,
що переповнює блок,
буде прихований. Для перегляду прихованого контенту з'являться скролбар */

/* Значення auto схоже на значення scroll. Є й відмінність — при значенні auto показуються тільки ті скроллбари,
які дійсно необхідні. */

/* У таблиці стилів браузера кожного елемента встановлено його тип,
що визначає його поведінку
Найпоширенішими є блокові (block) та рядкові (inline) елементи. Крім цього,
є ще їхній гібрид - рядково-блокові (inline-block).
Рядкові елементи призначені для виділення та оформлення текстового контенту. Наприклад посилань кнопок,
зображень тощо. Блокові елементи використовуються для розмітки текстових контейнерів (заголовків, списків, 
абзаців) і великих смислових розділів (секцій, шапки, підвалу). */

/* Якщо задати автоматичні лівий і правий маржини,
вільний простір розподіляється між ними,
і блочний елемент центрується. .box {
        width: 300px;
        background-color: tomato;
        margin-right: auto;
        margin-left: auto;
} */

/* Тег div — це універсальний контейнер без семантичного значення. 
Використовується як блок-обгортка для групування та подальшої стилізації вмісту.
 Обирай тег div,
якщо тобі просто потрібен загальний контейнер для оформлення;
не виходить дати групі тегів окреме ім'я, що повністю описує вміст.


<div class="container"></div> */

/* Для рядкових елементів задається властивість display: inline. 
Їхня ширина та висота залежать тільки від вмісту,
явно задати їх не можна. Тобто властивості width і height не мають жодного ефекту. 
Вони розташовуються в рядку,
доки в ньому є достатньо місця,
після чого нові елементи переносяться на наступний рядок. 
Їм можна задавати лише горизонтальну геометрію: ліві та праві маржини,
падінги та рамки. Тобто вони ігнорують значення верхніх і нижніх 'margin',
'padding' і border. */

/* Рядково-блокові елементи (inline-block) — це гібрид між блочними та рядковими елементами,
який взяв корисне від обох. Для них задана властивість display: inline-block. 
Їх ширина і висота залежать від вмісту,
але можна явно задати властивості width і height. Вони розташовуються в рядку доти,
поки в ньому є достатньо місця,
після чого нові переносяться на наступний рядок. Їм можна задавати будь-які властивості 
геометрії елемента: ширину,
висоту,
поля,
рамки та відступи. Рядково-блокові елементи використовуються в тих випадках,
коли рядковим елементам потрібно додати декоративні ефекти. */

/* Приклади таких задач: Задати для посилання вертикальні падінги,
маржини або ширину з висотою,
візуально зробивши з неї кнопку;
Перетворити <span>на іконку з фіксованими розмірами. */

/* У рядкових та рядково-блочних елементів є правий проміжок. Це не margin або padding,
а буквально порожнє місце. Це особливість того,
як браузер розташовує рядковий контент у рядку.
Величина цього проміжку визначається: розміром тексту найближчого батьківського елемента 
з явно визначеним значенням Або якщо такого батьківського елемента немає,
використовується розмір шрифту від браузера за замовчуванням - 16px. 
Тому у кнопок,
посилань,
зображень,
спанів і інших рядкових елементів за умовчанням буде проміжок 4px — 1/4 розміру шрифту 
найближчого батьківського елемента.
У живому прикладі ми задали body розмір шрифту 32px,
тому між рядковими елементами є відстань 8px — 1/4 від поточного значення розміру шрифту.
*/

/* Приховані елементи Значення display: none дозволяє повністю приховати елемент,
звільнивши його простір для інших. Такий елемент вилучається з потоку документа,
візуально приховується й відсутній у розкладці сторінки. */

/* Нижній проміжок рядкового елемента Зображення — це рядковий елемент. 
Отже,
між двома зображеннями чи зображенням і іншим рядковим елементом буде відстань
 по горизонталі. Це ми вже знаємо і скоро навчимося обходити. 
 Зображення — особливий елемент тому,
що в нього крім правого зазору є ще нижній зазор рядкового елемента,
за розміром такий самий,
як і горизонтальний. 
На практиці цей проміжок ніколи не потрібний й тільки заважає. 
Його дуже просто прибрати. Достатньо зробити зображення блоковим елементом !
*/

/* Гумові зображення Розберемо,
що робить властивість max-width: 100%. За замовчуванням зображення відображається 
у своєму оригінальному розмірі. Отже,
якщо атрибути розміру для тега img не вказані,
зображення виходить за рамки батьківського елемента з 
фіксованою шириною (див. схему нижче). Таке буває,
коли ширина зображення не вказується жорстко й залежить від ширини батьківського елемента. */

/* Властивість object-fit визначає яким чином вміст елемента img буде вміщатися в контейнер,
коли розміри чи пропорції зображення та контейнера не збігаються. Зображення можна обрізати,
розтягувати чи масштабувати. object-fit: fill | contain | cover | scale-down | none fill — зображення масштабується без збереження пропорцій,
щоб повністю заповнити контейнер. Значення за замовчуванням. contain — зображення масштабується зі збереженням пропорцій,
щоб максимально заповнити контейнер. cover — зображення масштабується зі збереженням пропорцій,
щоб повністю заповнити контейнер. scale-down — буде вибрано значення none або contain,
щоб зображення було найменшого розміру. Мета — вмістити все зображення без зміни пропорцій. none — зберігаються вихідні розміри зображення,
задана висота та ширина не мають жодного ефекту. */

/* Flexbox-контейнер може: змінювати ширину і висоту його дітей;
змінювати напрямок розташування його дітей (вирівнювання в колонку або рядок);
змінювати порядок відображення елементів та відстань між ними;
розширювати елементи,
щоб оптимально заповнити доступний простір;
стискати елементи,
щоб запобігти переповненню. У flex-контейнері скасовується більшість правил розташування
 елементів відповідно до їх типу та потоку документа. — Елементи втрачають «тип»,
перестають бути рядковими або блоковими,
вони стають flex-елементами. — Блокові елементи перестають йти вертикально один під одним.
 — Маржини елементів на краю батьківського елементу не випадають.
  — Вертикальні маржини не схлопуються. — Працюють автоматичні вертикальні відступи. */

/* Головні осі flex-контейнера Звичайний порядок розташування елементів визначається 
потоком документа та їх типом (блоковий чи рядковий). Але ти вже знаєш,
що в Flexbox це не так. У моделі Flexbox напрямок розташування елементів 
визначається направляючими осями контейнера,
вздовж яких вибудовуються елементи. Розглянемо основні осі контейнеру. 
Це абсолютно необхідно для розуміння на що впливатимуть властивості,
що ми будемо вивчати у наступному блоці. Main axis Main axis — головна вісь flex-контейнера,
вздовж якої розміщуються елементи. Напрямок main axis контролюється 
властивістю flex-direction. Вона може бути: горизонтальною (sample A) вертикальною (sample B) 
Cross axis Cross axis - поперечна вісь,
яка завжди перпендикулярна головній осі (main axis). Її напрямок явно не встановлюється,
бо завжди залежить від якщо main axis — горизонтальна,
cross axis — вертикальна (sample A) якщо main axis — вертикальна,
cross axis — горизонтальна (sample B)
*/

/* Початок та кінець flex-контейнера Модель Flexbox має точки "start" та "end" 
для визначення порядку елементів всередині flex-контейнера. Осі (main axis, cross axis) 
визначають лінії вздовж яких розташовуються елементи. Точки "start" та "end" — це буквально 
точки початку та кінця на головній або поперечній осі. Саме вони визначають де буде перший,
а де останній елемент по осі. Розглянемо початок та кінець 
по осі main axis main-start і main-end — елементи в контейнері завжди 
розташовуються від main-start (початок головної осі) і до main-end (кінець головної осі). 
Що ж таке cross-start і cross-end? cross-start і cross-end - початок і кінець 
поперечної осі cross axis вздовж якої розташовані рядки елементів.
*/

/* Flex-контейнер (далі просто контейнер) — це батьківський елемент групи елементів,
який дозволяє змінити порядок розташування елементів усередені. Саме властивості 
контейнера контролюють: напрямок осей,
багаторядковість і позиціонування елементів у рядку */

/* gap: 8px; зазори між флекс елементами*/

/* Flexbox — це система розташування елементів в одному напрямку: горизонтально чи вертикально. 
Властивість flex-direction задає напрямок головної осі,
а отже визначає напрямок елементів у контейнері. */

/* flex-direction: row | row-reverse | column | column-reverse row — вісь 
починається зліва й закінчується праворуч. Це значення за замовчуванням.
 row-reverse — вісь починається праворуч й закінчується ліворуч. 
 column — головна вісь стає вертикально,
початок зверху та кінець знизу. column-reverse — головна вісь розташовується вертикально,
початок знизу,
кінець зверху.
Отже,
ця властивість міняє місцями main-start і main-end головної осі. Flex-елементи завжди 
будуть розміщені вздовж головної осі від початку (main-start) до кінця (main-end).
*/

/* Властивість justify-content керує позиціонуванням елементів на головній осі,
від main-start до main-end. justify-content: flex-start | flex-end | center | 
space-between | space-around | space-evenly 
flex-start — елементи притискаються до точки main-start головної осі. 
Це значення за замовчуванням. 
flex-end — елементи притискаються до точки main-end головної осі. 
center — елементи центруються на осі. space-between — елементи рівномірно 
розподіляються на головній осі. Перший елемент встановлюється на початок осі,
а останній на кінець. space-around — елементи розподіляються рівномірно,
але лівий та правий елементи розташовані на відстані від рамок контейнера 
на половину проміжку між іншими елементами. space-evenly — елементи розподіляються так,
що відстань між елементами та від крайніх елементів до меж контейнера однакова.
*/

/* Властивість flex-direction задає напрямок головній і поперечній осям. 
Властивість justify-content керує розташуванням елементів уздовж головної осі. Тобто,
якщо main axis горизонтально,
можна елементи по горизонталі переміщувати. Але як,
у такому разі,
керувати елементами по висоті? */

/* Властивість align-items керує розташуванням елементів вздовж поперечної осі cross axis. 
Це аналог justify-content тільки для іншої осі.
stretch — елементи розтягуються по всій довжині осі cross axis. 
Це значення за замовчуванням. flex-start — елементи притискаються до точки cross start. 
flex-end — елементи притискаються до точки cross end. center — елементи центруються 
по осі cross axis. 
baseline — елементи вирівнюються по базовій лінії їхнього текстового вмісту. */
/* 
За замовчуванням display: flex створює однорядковий контейнер,
елементи розміщуються на одному рядку й за потреби стискаються. Властивість flex-wrap дозволяє перетворити 
однорядковий контейнер на багаторядковий. Елементи будуть додаватися в рядок,
доки в ньому буде місце,
після чого буде автоматично створено ще один рядок. */

/* nowrap — усі елементи будуть на одному рядку. 
Це значення за замовчуванням. wrap — дозволяє елементам перестрибувати на інші рядки,
які за замовчуванням розташовуються зверху вниз (уздовж cross axis).
 wrap-reverse — дозволяє елементам перестрибувати на інші рядки,
які розташовуються знизу вгору (уздовж cross axis). */

/* Останній крок — задати розмір flex-елементів li.item.
 Ширина вказується у відсотках від загальної ширини батьківського 
 елемента (100%) за такою формулою. 100% - кількість_проміжків_у_рядку * 
 значення_одного_проміжку) / кількість_елементів_у_рядку Кількість проміжків 
 між елементами в рядку завжди на одиницю менша за кількість елементів. 
 У нашій сітці три елементи в рядок,
отже в одному рядку є два проміжки по 10px. .item {
        width: calc((100% - 20px) / 3); */

/* Чому не використовувати фіксовані значення? Ширина елемента у відсотках — 
це масштабоване рішення,
        оскільки розміри елементів не потрібно буде перераховувати заново 
        при зміні ширини контейнера або проміжку між ними. */

/* Властивість align-content Керує вирівнюванням усіх рядків багаторядкового контейнера 
уздовж cross axis,
        якщо є вільне місце. Аналогічно тому,
        як align-items вирівнює елементи в кожному рядку. Ця властивість не діє,
        коли є лише один рядок елементів або в контейнері немає вільного місця за 
        вертикаллю (явно не задана висота більше, ніж контент).
stretch — рядки рівномірно розтягуються,
        щоб зайняти все місце. Значення за замовчуванням. flex-start — рядки 
        притискаються до старту cross axis. flex-end — рядки притискаються до 
        кінця cross axis. center — рядки центруються на осі cross axis. */

/* align-items керує вирівнюванням елементів уздовж cross axis у рамках одного рядка,
        align-content керує вирівнюванням усіх рядків багаторядкового контейнера
         уздовж cross axis,
        якщо є вільне місце. */

/* Flex-елементи — це діти flex-контейнера,
        елементи першого рівня вкладеності. У моделі Flexbox flex-елементи 
        (далі просто елементи):

                перестають підкорятися стандартному потоку документа;
        втрачають свій тип (блоковий, рядковий, тощо) та дотримуються правил 
        позиціонованої Flexbox-моделі. */

/* Властивість flex-basis Властивість flex-basis визначає початковий 
розмір flex-елемента у flex-контейнері. */

/* Якщо застосовано обидві властивості,
        flex-basis і width,
        то властивість width ігнорується. Властивість flex-basis може визначати висоту,
        а не ширину елемента. Це відбувається,
        коли напрямок головної осі вертикальний. Властивості min-width і max-width працюють,
        як обмежувачі розміру елемента,
        навіть якщо у нього вказано flex-basis. Властивість flex-basis — це не фінальний розмір елемента,
        а розмір до розподілу вільного простору,
        який регулюється властивостями flex-grow і flex-shrink. */

/* Властивість flex-grow Властивість flex-grow — визначає здатність елемента займати більше місця (рости),

ніж початковий розмір. Значення визначається як пропорція (частка) вільного місця в контейнері.

flex-grow: частка За замовчуванням у всіх елементів встановлено значення 0. Тобто за замовчуванням 

елементи не намагаються зайняти додаткове вільне місце, навіть якщо таке є. Негативні значення задавати 

не можна. Важливо не те, яке 

значення flex-grow елемента саме по собі, а те, яке воно по відношенню до інших елементів. */

/* 
Властивість flex-shrink На противагу властивості flex-grow,
        flex-shrink визначає здатність flex-елемента займати менше місця (стискатися),
        ніж його початковий розмір,
        тобто впливає на фінальний розмір елемента. flex-shrink: значення;



        Значення задається у вигляді пропорції (частка, фактор). За замовчуванням
         у всіх елементів встановлено значення 1,
        тобто елементи стискатимуться за потреби. Значення 0 заборонить елементу 
        стискатися. Негативні значення задавати не можна. 
Щоб елемент іконки зайняв необхідні 40px за шириною,
        достатньо заборонити йому стискатися,
        задавши flex-shrink: 0. Так flex-контейнер виділить рівно 40px під іконку, 
        а решту місця в рядку займе абзац із текстом.
        */

/* Давай запам'ятаємо: align-items задається для контейнера та визначає вирівнювання
 всіх елементів у контейнері,
 а align-self задається окремому елементу. */


/* Псевдоклас :not() Псевдоклас :not() дозволяє вибрати всі елементи,
        що не підходять під критерій. Критерій вказується у вигляді простого селектора,
        записаного в дужках. Простий селектор — це універсальний селектор,
        селектор типу,
        ідентифікатора,
        атрибута,
        класу чи псевдокласу.:not(selector) Цей псевдоклас можна застосувати для того,
        щоб по-іншому вирішити задачу очищення крайнього маржина першого чи останнього елемента. Замість того,
        щоб в одному правилі задавати відступ всім,
        а потім не забути в іншому його обнулити для конкретного елемента,
        ми в одному правилі задаємо відступ усім елементам,
        крім одного. .list-item:not(:last-child) {
                margin-bottom: 20px;
Читається як:

застосувати стилі до всіх елементів із класом list-item, які не є останнім елементом у колекції сусідів.
Тобто такий селектор застосовується до всіх елементів колекції, крім останнього.
        } */

/* Парні та непарні елементи Псевдоклас :nth-child(an + b) 
вибирає елементи в колекції сусідів за номером,
вказаним у дужках,
за допомогою циклу an+b `,
який дозволяє задати правило для послідовності елементів. 
a — період циклу. Довільне число. n — лічильник циклу.
Починається з нуля та збільшується на одиницю на кожній ітерації.
 b — зміщення. Довільне число. Наприклад,
якщо a=2,
а b=1,
то an+b=2n+1. Ця формула вибере всі непарні елементи.
 # При n=0 2 * 0+1=1 # При n=1 2 * 1+1=3 # При n=2 2 * 2+1=5 # И так далее для n=3,
n=4 ... На практиці цей псевдоклас застосовується для вибору 
всіх парних чи непарних елементів колекції. Наприклад,
зробити рядки таблиці різного кольору через один. */